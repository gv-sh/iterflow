{
  "Import Iterflow": {
    "prefix": "iiter",
    "body": [
      "import { iter } from 'iterflow';"
    ],
    "description": "Import iter from iterflow"
  },
  "Import Iterflow Functional": {
    "prefix": "iiterfn",
    "body": [
      "import { map, filter, reduce } from 'iterflow/fn';"
    ],
    "description": "Import functional API from iterflow"
  },
  "Create Iterator": {
    "prefix": "iiter-create",
    "body": [
      "const result = iter(${1:data})",
      "  .${2:map}(${3:x => x})",
      "  .${4:toArray}();"
    ],
    "description": "Create an iterflow iterator"
  },
  "Map Transform": {
    "prefix": "imap",
    "body": [
      ".map(${1:x} => ${2:x})"
    ],
    "description": "Map transformation"
  },
  "Filter Transform": {
    "prefix": "ifilter",
    "body": [
      ".filter(${1:x} => ${2:x > 0})"
    ],
    "description": "Filter transformation"
  },
  "Reduce Terminal": {
    "prefix": "ireduce",
    "body": [
      ".reduce((${1:acc}, ${2:x}) => ${3:acc + x}, ${4:0})"
    ],
    "description": "Reduce to single value"
  },
  "Take N Items": {
    "prefix": "itake",
    "body": [
      ".take(${1:10})"
    ],
    "description": "Take first N items"
  },
  "Drop N Items": {
    "prefix": "idrop",
    "body": [
      ".drop(${1:10})"
    ],
    "description": "Drop first N items"
  },
  "Chunk Array": {
    "prefix": "ichunk",
    "body": [
      ".chunk(${1:5})"
    ],
    "description": "Chunk into arrays of size N"
  },
  "Window Sliding": {
    "prefix": "iwindow",
    "body": [
      ".window(${1:3})"
    ],
    "description": "Create sliding window"
  },
  "FlatMap Transform": {
    "prefix": "iflatmap",
    "body": [
      ".flatMap(${1:x} => ${2:[x, x * 2]})"
    ],
    "description": "FlatMap transformation"
  },
  "Unique Values": {
    "prefix": "iunique",
    "body": [
      ".unique()"
    ],
    "description": "Get unique values"
  },
  "Group By": {
    "prefix": "igroupby",
    "body": [
      ".groupBy(${1:x} => ${2:x.category})"
    ],
    "description": "Group by key function"
  },
  "Partition": {
    "prefix": "ipartition",
    "body": [
      ".partition(${1:x} => ${2:x > 0})"
    ],
    "description": "Partition into two groups"
  },
  "Zip Iterators": {
    "prefix": "izip",
    "body": [
      ".zip(${1:other})"
    ],
    "description": "Zip with another iterator"
  },
  "Enumerate": {
    "prefix": "ienumerate",
    "body": [
      ".enumerate()"
    ],
    "description": "Add index to each element"
  },
  "To Array": {
    "prefix": "itoarray",
    "body": [
      ".toArray()"
    ],
    "description": "Convert to array"
  },
  "To Set": {
    "prefix": "itoset",
    "body": [
      ".toSet()"
    ],
    "description": "Convert to Set"
  },
  "To Map": {
    "prefix": "itomap",
    "body": [
      ".toMap(${1:x} => [${2:x.id}, ${3:x}])"
    ],
    "description": "Convert to Map"
  },
  "Mean Calculation": {
    "prefix": "imean",
    "body": [
      ".mean()"
    ],
    "description": "Calculate mean/average"
  },
  "Median Calculation": {
    "prefix": "imedian",
    "body": [
      ".median()"
    ],
    "description": "Calculate median"
  },
  "Sum": {
    "prefix": "isum",
    "body": [
      ".sum()"
    ],
    "description": "Sum all values"
  },
  "Min Value": {
    "prefix": "imin",
    "body": [
      ".min()"
    ],
    "description": "Find minimum value"
  },
  "Max Value": {
    "prefix": "imax",
    "body": [
      ".max()"
    ],
    "description": "Find maximum value"
  },
  "Count Items": {
    "prefix": "icount",
    "body": [
      ".count()"
    ],
    "description": "Count items"
  },
  "Find Item": {
    "prefix": "ifind",
    "body": [
      ".find(${1:x} => ${2:x > 0})"
    ],
    "description": "Find first matching item"
  },
  "Some Test": {
    "prefix": "isome",
    "body": [
      ".some(${1:x} => ${2:x > 0})"
    ],
    "description": "Test if any item matches"
  },
  "Every Test": {
    "prefix": "ievery",
    "body": [
      ".every(${1:x} => ${2:x > 0})"
    ],
    "description": "Test if all items match"
  },
  "Functional Pipeline": {
    "prefix": "ipipe",
    "body": [
      "import { pipe, map, filter, take } from 'iterflow/fn';",
      "",
      "const result = pipe(",
      "  ${1:data},",
      "  map(${2:x => x * 2}),",
      "  filter(${3:x => x > 0}),",
      "  take(${4:10})",
      ");"
    ],
    "description": "Create functional pipeline"
  },
  "Async Iterator": {
    "prefix": "iasync",
    "body": [
      "import { asyncIter } from 'iterflow';",
      "",
      "const result = await asyncIter(${1:asyncData})",
      "  .${2:map}(async ${3:x} => ${4:x})",
      "  .${5:toArray}();"
    ],
    "description": "Create async iterator"
  },
  "Moving Average": {
    "prefix": "imovingavg",
    "body": [
      ".window(${1:3})",
      ".map(window => window.reduce((a, b) => a + b, 0) / window.length)"
    ],
    "description": "Calculate moving average"
  },
  "Standard Deviation": {
    "prefix": "istddev",
    "body": [
      ".stddev()"
    ],
    "description": "Calculate standard deviation"
  },
  "Variance": {
    "prefix": "ivariance",
    "body": [
      ".variance()"
    ],
    "description": "Calculate variance"
  }
}
